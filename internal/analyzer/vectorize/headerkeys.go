package vectorize

import (
	"crypto/rand"
	"math/big"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/TheHackerDev/cartograph/internal/analyzer/vectorize/bagofwords"
)

// headerKeys.go contains the code to vectorize header keys.

// headerKeysMap is a map of the header keys to their index in the vector.
var headerKeysMap map[string]int

// init initializes the headerKeysMap, and runs before the main function.
func init() {
	// Convert the headers to a map for faster lookup, where the value is the index in the vector.
	headerKeysMap = make(map[string]int, len(bagofwords.HeaderKeys))
	for i, header := range bagofwords.HeaderKeys {
		headerKeysMap[header] = i
	}
}

// HeaderKeys converts the slices of request and response header keys to a vector.
func HeaderKeys(requestHeaderKeys, responseHeaderKeys []string) []float32 {
	vector := make([]float32, len(bagofwords.HeaderKeys))

	// Iterate through the request headers and update the vector
	for _, key := range requestHeaderKeys {
		if index, ok := headerKeysMap[strings.ToLower(key)]; ok {
			vector[index] = 1
		}
	}

	// Iterate through the response headers and update the vector
	for _, key := range responseHeaderKeys {
		if index, ok := headerKeysMap[strings.ToLower(key)]; ok {
			vector[index] = 1
		}
	}

	return vector
}

// GenerateHeaderKeysVector generates a vector of header keys for testing purposes.
// The vector is generated by randomly selecting a number of headers from the list of headers, up to the max number
// of headers.
func GenerateHeaderKeysVector() []float32 {
	maxHeadersInVector := 10

	vector := make([]float32, len(bagofwords.HeaderKeys))

	// Randomly select a number of headers to add to the vector, up to the max number of headers
	numHeaders, randErrSmall := rand.Int(rand.Reader, big.NewInt(int64(maxHeadersInVector)))
	if randErrSmall != nil {
		log.Fatal("Error generating random number for header keys vector generation")
	}
	for i := int64(0); i < numHeaders.Int64(); i++ {
		// Randomly select a header to add to the vector
		index, randErrBig := rand.Int(rand.Reader, big.NewInt(int64(len(bagofwords.HeaderKeys))))
		if randErrBig != nil {
			log.Fatal("Error generating random number for header keys vector generation")
		}
		vector[index.Int64()] = 1
	}

	return vector
}
